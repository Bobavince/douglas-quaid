
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>common.Graph.graph_datastructure &#8212; Douglas-Quaid 0.0.4 documentation</title>
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Douglas-Quaid 0.0.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for common.Graph.graph_datastructure</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>

<span class="kn">import</span> <span class="nn">common.ImportExport.json_import_export</span> <span class="k">as</span> <span class="nn">json_import_export</span>
<span class="kn">from</span> <span class="nn">common.Graph</span> <span class="k">import</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">node</span>
<span class="kn">from</span> <span class="nn">common.PerformanceDatastructs.clustermatch_datastruct</span> <span class="k">import</span> <span class="n">ClusterMatch</span>
<span class="kn">from</span> <span class="nn">common.environment_variable</span> <span class="k">import</span> <span class="n">load_server_logging_conf_file</span>

<span class="n">load_server_logging_conf_file</span><span class="p">()</span>


<div class="viewcode-block" id="GraphDataStruct"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.GraphDataStruct">[docs]</a><span class="k">class</span> <span class="nc">GraphDataStruct</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handle the complete graph</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meta</span><span class="p">:</span> <span class="n">metadata</span><span class="o">.</span><span class="n">Metadata</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">meta</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">cluster</span><span class="o">.</span><span class="n">Cluster</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># ==================== Adding elements to the graph ====================</span>

<div class="viewcode-block" id="GraphDataStruct.add_node"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.GraphDataStruct.add_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">Node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a node to the graph (a picture, not a cluster)</span>
<span class="sd">        :param node: Node to add to the graph</span>
<span class="sd">        :return: Nothing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span></div>

<div class="viewcode-block" id="GraphDataStruct.add_cluster"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.GraphDataStruct.add_cluster">[docs]</a>    <span class="k">def</span> <span class="nf">add_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="n">cluster</span><span class="o">.</span><span class="n">Cluster</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a cluster to the graph (not a picture)</span>
<span class="sd">        :param cluster: Cluster to add to the graph</span>
<span class="sd">        :return: Nothing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">cluster</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster</span></div>

<div class="viewcode-block" id="GraphDataStruct.add_cluster_with_nodes"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.GraphDataStruct.add_cluster_with_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">add_cluster_with_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="n">cluster</span><span class="o">.</span><span class="n">Cluster</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">Node</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a cluster to the graph with its nodes</span>
<span class="sd">        :param cluster: Cluster to add to the graph</span>
<span class="sd">        :param nodes: List of nodes to add to the graph and to link to the cluster</span>
<span class="sd">        :param color: Color of the links between this cluster and these nodes</span>
<span class="sd">        :return: Nothing</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">cluster</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster</span>

        <span class="c1"># For each node, add the node and add an edge between the cluster and the node</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">Edge</span><span class="p">(</span><span class="n">cluster</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">color</span><span class="p">))</span></div>

<div class="viewcode-block" id="GraphDataStruct.add_edge"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.GraphDataStruct.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="n">edge</span><span class="o">.</span><span class="n">Edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an edge to the graph</span>
<span class="sd">        :param edge: Edge to add to the graph</span>
<span class="sd">        :return: Nothing</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">_from</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">_from</span><span class="p">]</span><span class="o">.</span><span class="n">add_member_id</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">_to</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">_to</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">_to</span><span class="p">]</span><span class="o">.</span><span class="n">add_member_id</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">_from</span><span class="p">)</span></div>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    def rem_edge(self, edge:edge.Edge):</span>
<span class="sd">        # Remove an edge to the graph</span>
<span class="sd">        self.edges.remove(edge)</span>
<span class="sd">        if edge._from in self.clusters.keys():</span>
<span class="sd">            self.clusters[edge._from].remove_member_id(edge._to)</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># ==================== Request ====================</span>

<div class="viewcode-block" id="GraphDataStruct.are_ids_in_same_cluster"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.GraphDataStruct.are_ids_in_same_cluster">[docs]</a>    <span class="k">def</span> <span class="nf">are_ids_in_same_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_1</span><span class="p">,</span> <span class="n">id_2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if both nodes ids are in this cluster (by ids) # TODO : make test !</span>
<span class="sd">        :param id_1: first id</span>
<span class="sd">        :param id_2: second id</span>
<span class="sd">        :return: True if both ids are in the same cluster, false otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">are_in_same</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">are_in_same_cluster</span><span class="p">(</span><span class="n">id_1</span><span class="p">,</span> <span class="n">id_2</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">are_in_same</span></div>

<div class="viewcode-block" id="GraphDataStruct.are_names_in_same_cluster"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.GraphDataStruct.are_names_in_same_cluster">[docs]</a>    <span class="k">def</span> <span class="nf">are_names_in_same_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">name_2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if both nodes id are in this cluster (by name).</span>
<span class="sd">        Translate names to id and fallback to check if ids in same cluster # TODO : make test !</span>
<span class="sd">        :param name_1: first name</span>
<span class="sd">        :param name_2: second name</span>
<span class="sd">        :return: True if both names are in the same cluster, false otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">one_found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">id_1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">id_2</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># For each node</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">image</span> <span class="o">==</span> <span class="n">name_1</span><span class="p">:</span>
                <span class="n">id_1</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">one_found</span><span class="p">:</span>  <span class="c1"># First id found = Continue</span>
                    <span class="n">one_found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">one_found</span><span class="p">:</span>
                    <span class="k">break</span>  <span class="c1"># Second id found ! = Stop</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">image</span> <span class="o">==</span> <span class="n">name_2</span><span class="p">:</span>
                <span class="n">id_2</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">one_found</span><span class="p">:</span>  <span class="c1"># First id found = Continue</span>
                    <span class="n">one_found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">one_found</span><span class="p">:</span>
                    <span class="k">break</span>  <span class="c1"># Second id found ! = Stop</span>

        <span class="k">if</span> <span class="n">id_1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">id_2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Image Name not found in graph structure ! </span><span class="si">{id_1}</span><span class="s2"> or </span><span class="si">{id_2}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">are_ids_in_same_cluster</span><span class="p">(</span><span class="n">id_1</span><span class="p">,</span> <span class="n">id_2</span><span class="p">)</span></div>

    <span class="c1"># ==================== Conversion ====================</span>

<div class="viewcode-block" id="GraphDataStruct.replace_id_from_mapping"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.GraphDataStruct.replace_id_from_mapping">[docs]</a>    <span class="k">def</span> <span class="nf">replace_id_from_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_to_id</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace olds id by new ids, if provided in the input list (filename_to_id).</span>
<span class="sd">        Ex : {&quot;toto&quot;:id=2} input with {Edge : {&quot;toto&quot;:id=1}} input =&gt; {Edge : {&quot;toto&quot;:id=2}} output</span>
<span class="sd">        :param filename_to_id: a mapping from name to ids</span>
<span class="sd">        :return: a mapping from old id to new ids (Ex : {2:1} in previus example) + change state of the graph</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mapping_old_id_new_id</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># For all nodes, transform the input mapping into a dict</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">tmp_old_id</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span>
            <span class="c1"># Modify the name if presents in the provided mapping, or keep original id</span>
            <span class="n">n</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">filename_to_id</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="c1"># Store the modification in a mapping</span>
            <span class="n">mapping_old_id_new_id</span><span class="p">[</span><span class="n">tmp_old_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span>

        <span class="c1"># For all clusters updates ids</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">mapping_old_id_new_id</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">c</span><span class="o">.</span><span class="n">update_member_id</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

        <span class="c1"># For all edges updates ids</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">mapping_old_id_new_id</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">e</span><span class="o">.</span><span class="n">update_member_id</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Be aware that performing an ID mapping can leads to node fusion : some nodes can be mapped to the same id, and so, some nodes can be lost.&quot;</span><span class="p">)</span>

        <span class="c1"># Reconstruct node dict, with new ids</span>
        <span class="n">tmp_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">tmp_dict</span>

        <span class="c1"># Reconstruct cluster dict, with new ids</span>
        <span class="n">tmp_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">tmp_dict</span>

        <span class="k">return</span> <span class="n">mapping_old_id_new_id</span></div>

<div class="viewcode-block" id="GraphDataStruct.get_clusters"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.GraphDataStruct.get_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">get_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">cluster</span><span class="o">.</span><span class="n">Cluster</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the list of cluster</span>
<span class="sd">        :return: List of clusters of the graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>

<div class="viewcode-block" id="GraphDataStruct.get_edges_dict"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.GraphDataStruct.get_edges_dict">[docs]</a>    <span class="k">def</span> <span class="nf">get_edges_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of edges as a dict in the order (node_id =&gt; has edge to =&gt; cluster_id)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tmp_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">_from</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>  <span class="c1"># &quot;From&quot; is a cluster</span>
                <span class="n">tmp_dict</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">_to</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">_from</span>
            <span class="k">elif</span> <span class="n">edge</span><span class="o">.</span><span class="n">_to</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>  <span class="c1"># &quot;To&quot; is a cluster</span>
                <span class="n">tmp_dict</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">_from</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">_to</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Edge between two nodes ?</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Edges between nodes without cluster are not handled (for now).&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tmp_dict</span></div>

    <span class="c1"># ==================== Export / Import ====================</span>

<div class="viewcode-block" id="GraphDataStruct.copy_ids_to_image"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.GraphDataStruct.copy_ids_to_image">[docs]</a>    <span class="k">def</span> <span class="nf">copy_ids_to_image</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy &quot;id&quot; values of nodes to their &quot;image&quot; field</span>
<span class="sd">        (useful if we have no image, and id are actual path)</span>
<span class="sd">        :return: Nothing (+ change the internal state)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tmp_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">tmp_node</span><span class="o">.</span><span class="n">copy_ids_to_image</span><span class="p">()</span></div>

<div class="viewcode-block" id="GraphDataStruct.export_as_dict"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.GraphDataStruct.export_as_dict">[docs]</a>    <span class="k">def</span> <span class="nf">export_as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export the current graph as a dict</span>
<span class="sd">        :return: A dict version of the graph</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tmp_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">tmp_dict</span><span class="p">[</span><span class="s2">&quot;meta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">export_as_dict</span><span class="p">()</span>
        <span class="n">tmp_dict</span><span class="p">[</span><span class="s2">&quot;clusters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">cluster</span><span class="o">.</span><span class="n">export_as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">tmp_dict</span><span class="p">[</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">export_as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">tmp_dict</span><span class="p">[</span><span class="s2">&quot;edges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">export_as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">tmp_dict</span></div>

<div class="viewcode-block" id="GraphDataStruct.load_from_dict"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.GraphDataStruct.load_from_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">load_from_dict</span><span class="p">(</span><span class="n">tmp_input</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load/ Import a graph from a dict</span>
<span class="sd">        :param tmp_input: A Dict version of the graph to import</span>
<span class="sd">        :return: The graph as an object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">meta</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">Metadata</span><span class="o">.</span><span class="n">load_from_dict</span><span class="p">(</span><span class="n">tmp_input</span><span class="p">[</span><span class="s2">&quot;meta&quot;</span><span class="p">])</span>
        <span class="n">tmp_graph</span> <span class="o">=</span> <span class="n">GraphDataStruct</span><span class="p">(</span><span class="n">meta</span><span class="p">)</span>

        <span class="n">tmp_clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">cluster</span><span class="o">.</span><span class="n">Cluster</span><span class="o">.</span><span class="n">load_from_dict</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">cluster_dict</span> <span class="ow">in</span> <span class="n">tmp_input</span><span class="p">[</span><span class="s2">&quot;clusters&quot;</span><span class="p">]]</span>
        <span class="n">tmp_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">Node</span><span class="o">.</span><span class="n">load_from_dict</span><span class="p">(</span><span class="n">node_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">node_dict</span> <span class="ow">in</span> <span class="n">tmp_input</span><span class="p">[</span><span class="s2">&quot;nodes&quot;</span><span class="p">]]</span>
        <span class="n">tmp_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">Edge</span><span class="o">.</span><span class="n">load_from_dict</span><span class="p">(</span><span class="n">edge_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge_dict</span> <span class="ow">in</span> <span class="n">tmp_input</span><span class="p">[</span><span class="s2">&quot;edges&quot;</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tmp_clusters</span><span class="p">:</span>
            <span class="n">tmp_graph</span><span class="o">.</span><span class="n">add_cluster</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tmp_nodes</span><span class="p">:</span>
            <span class="n">tmp_graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tmp_edges</span><span class="p">:</span>
            <span class="n">tmp_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tmp_graph</span></div></div>


<div class="viewcode-block" id="merge_graphs"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.merge_graphs">[docs]</a><span class="k">def</span> <span class="nf">merge_graphs</span><span class="p">(</span><span class="n">visjs_graph</span><span class="p">:</span> <span class="n">GraphDataStruct</span><span class="p">,</span> <span class="n">db_graph</span><span class="p">:</span> <span class="n">GraphDataStruct</span><span class="p">,</span> <span class="n">cluster_mapping</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ClusterMatch</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Merge two graphs into one unique graph. Uses the list of clusters matches to merge each cluster with each other.</span>
<span class="sd">    Merge a visjs and db graph to produce only one visjs graph, with colors depending on good/bad matches</span>
<span class="sd">    :param visjs_graph: The first graph to merge (ground truth one)</span>
<span class="sd">    :param db_graph: The second graph to merge (extracted from server)</span>
<span class="sd">    :param cluster_mapping: The list of clusterMatch that say &quot;This cluster is the same as this one&quot; for the merge.</span>
<span class="sd">    :return: A datastructure (json style/ dict style) that displays all data</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">tmp_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Merge metas</span>
    <span class="n">tmp_dict</span><span class="p">[</span><span class="s2">&quot;meta_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">visjs_graph</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">export_as_dict</span><span class="p">()</span>
    <span class="n">tmp_dict</span><span class="p">[</span><span class="s2">&quot;meta_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">db_graph</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">export_as_dict</span><span class="p">()</span>

    <span class="c1"># No need to merge nodes or clusters, we keep ones from graph one</span>
    <span class="n">tmp_dict</span><span class="p">[</span><span class="s2">&quot;clusters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">export_as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">visjs_graph</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="n">tmp_dict</span><span class="p">[</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">export_as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">visjs_graph</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

    <span class="c1"># Construct cluster mapping db_id =&gt; vis_id</span>
    <span class="c1"># DEBUG pprint.pprint(cluster_mapping)</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">cluster_pair</span><span class="o">.</span><span class="n">cluster_2</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">cluster_pair</span><span class="o">.</span><span class="n">cluster_1</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">cluster_pair</span> <span class="ow">in</span> <span class="n">cluster_mapping</span><span class="p">}</span>

    <span class="c1"># Create dict node_id =&gt; cluster_id for vis graph and db graph</span>
    <span class="n">vis_edges</span> <span class="o">=</span> <span class="n">visjs_graph</span><span class="o">.</span><span class="n">get_edges_dict</span><span class="p">()</span>
    <span class="n">db_edges</span> <span class="o">=</span> <span class="n">db_graph</span><span class="o">.</span><span class="n">get_edges_dict</span><span class="p">()</span>

    <span class="c1"># Convert db cluster id to visjs cluster id</span>
    <span class="n">db_edges</span> <span class="o">=</span> <span class="p">{</span><span class="n">edge_from</span><span class="p">:</span> <span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">edge_to</span><span class="p">,</span> <span class="s2">&quot;ERROR&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge_from</span><span class="p">,</span> <span class="n">edge_to</span> <span class="ow">in</span> <span class="n">db_edges</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="n">new_edges_list</span> <span class="o">=</span> <span class="n">merge_edges_with_colors</span><span class="p">(</span><span class="n">vis_edges</span><span class="p">,</span> <span class="n">db_edges</span><span class="p">)</span>

    <span class="n">tmp_dict</span><span class="p">[</span><span class="s2">&quot;edges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">export_as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">new_edges_list</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">tmp_dict</span></div>


<div class="viewcode-block" id="merge_edges_with_colors"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.merge_edges_with_colors">[docs]</a><span class="k">def</span> <span class="nf">merge_edges_with_colors</span><span class="p">(</span><span class="n">vis_edges</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">db_edges</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">Edge</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge a edges of two graphs with colors depending on good/bad matches</span>
<span class="sd">    :param vis_edges: The first edges set to merge (ground truth one)</span>
<span class="sd">    :param db_edges: The second edges set to merge (extracted from server)</span>
<span class="sd">    :return: A list of edges with colors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Merge edges dictionnary</span>
    <span class="n">edge_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate over visjs edges</span>
    <span class="k">for</span> <span class="n">v_edge_from</span><span class="p">,</span> <span class="n">v_edge_to</span> <span class="ow">in</span> <span class="n">vis_edges</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># If edge is present in db and with same &quot;to&quot;, put green</span>
        <span class="k">if</span> <span class="n">v_edge_from</span> <span class="ow">in</span> <span class="n">db_edges</span> <span class="ow">and</span> <span class="n">v_edge_to</span> <span class="o">==</span> <span class="n">db_edges</span><span class="p">[</span><span class="n">v_edge_from</span><span class="p">]:</span>
            <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">Edge</span><span class="p">(</span><span class="n">v_edge_from</span><span class="p">,</span> <span class="n">v_edge_to</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;green&quot;</span><span class="p">}))</span>

        <span class="c1"># If edge is present in db, but not with same &quot;to&quot;, put red</span>
        <span class="k">elif</span> <span class="n">v_edge_from</span> <span class="ow">in</span> <span class="n">db_edges</span> <span class="ow">and</span> <span class="n">v_edge_to</span> <span class="o">!=</span> <span class="n">db_edges</span><span class="p">[</span><span class="n">v_edge_from</span><span class="p">]:</span>
            <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">Edge</span><span class="p">(</span><span class="n">v_edge_from</span><span class="p">,</span> <span class="n">v_edge_to</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;orange&quot;</span><span class="p">}))</span>
            <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">Edge</span><span class="p">(</span><span class="n">v_edge_from</span><span class="p">,</span> <span class="n">db_edges</span><span class="p">[</span><span class="n">v_edge_from</span><span class="p">],</span> <span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;red&quot;</span><span class="p">}))</span>

        <span class="c1"># If edge is not present in db, problem = put black</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># v_edge_from not in db_edges :</span>
            <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">Edge</span><span class="p">(</span><span class="n">v_edge_from</span><span class="p">,</span> <span class="n">v_edge_to</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;black&quot;</span><span class="p">}))</span>

    <span class="k">return</span> <span class="n">edge_list</span></div>


<div class="viewcode-block" id="load_visjs_to_graph"><a class="viewcode-back" href="../../../common.Graph.html#common.Graph.graph_datastructure.load_visjs_to_graph">[docs]</a><span class="k">def</span> <span class="nf">load_visjs_to_graph</span><span class="p">(</span><span class="n">visjs_json_path</span><span class="p">:</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GraphDataStruct</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load VisJS to graph datastructure</span>
<span class="sd">    :param visjs_json_path: path to the visjs graph storage</span>
<span class="sd">    :return: The graph datastructure as an object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">visjs_json_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;VisJS ground truth path not set. Impossible to evaluate.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 1. Load pictures to visjs = node server.js -i ./../douglas-quaid/datasets/MINI_DATASET/ -t ./TMP -o ./TMP</span>
        <span class="c1"># 2. Cluster manually pictures in visjs = &lt; Do manual stuff&gt;</span>
        <span class="c1"># 3. Load json graphe</span>
        <span class="n">visjs</span> <span class="o">=</span> <span class="n">json_import_export</span><span class="o">.</span><span class="n">load_json</span><span class="p">(</span><span class="n">visjs_json_path</span><span class="p">)</span>
        <span class="n">visjs</span> <span class="o">=</span> <span class="n">GraphDataStruct</span><span class="o">.</span><span class="n">load_from_dict</span><span class="p">(</span><span class="n">visjs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">visjs</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Douglas-Quaid 0.0.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Vincent FALCONIERI.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>